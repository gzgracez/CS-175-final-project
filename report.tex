\documentclass[12pt]{article}
\usepackage[margin=1.10in]{geometry}                
\geometry{letterpaper}                  
\usepackage{graphicx}
\usepackage{amsmath, amssymb, amsthm}
\usepackage{hyperref, multicol}
\usepackage{graphicx}
\usepackage{float}
\hypersetup{colorlinks=false, allcolors=blue}
\usepackage{indentfirst}
\usepackage{titlesec}
\newcommand{\sectionbreak}{\clearpage}
\newcommand{\noin}{\noindent}                    
                        
\begin{document}

\title{%
  \textbf{CS 175: Roll-A-Bunny \\
  \large Final Project Report}}
\author{Grace Zhang, Yong Li Dich}
\date{}
\maketitle

\newpage
\tableofcontents

% TODO:
% screenshots
% references

\newpage
 
\section{Roll-A-Bunny Overview}
  For our CS 175 project, we decided to create a game called \textbf{Roll-A-Bunny} by building on what we've learned in class, and extending it to create this cross-platform game in Unity.
\subsection{Goal}
  Roll-A-Bunny is a combination of two classics: Whack-A-Mole + Roll-A-Ball, as well as our love for bunnies in CS 175. The goal of Roll-A-Bunny is to roll your player (a sphere) over all 9 bunnies while collecting as many yellow collectibles (12 in total) as possible in under 60 seconds. 
  You win if you are able to roll over all 9 bunnies and your score will be the number of collectibles you were able to collect in the process. If you are unable to roll over all 9 bunnies within 60 seconds, you will unfortunately lose the game.

  Throughout these 60 seconds, the bunnies will pop up and down in their respective positions on the 3 by 3 grid and the yellow collectibles will be rotating in place, scattered across the surface. 
  
\subsection{Navigation}
  Your player can be controlled via the arrow keys or the WASD keys. 
  There are 4 walls that enclose the 3 by 3 space and your player will be limited to this area. 

\subsection{Scoring / Metrics}
\begin{itemize}
  \item Bunnies - each bunny will only appear in its designated cell on the 3 by 3 grid, and upon collision with a bunny, it will disappear and the bunnyiescounter will be incremented by 1. 
  \item Yellow Collectibles - upon collision with a yellow collectible, the collectible will disappear and your score will be incremented by 1.
\end{itemize}


\section{Project Components and Hierarchy}
  We focused on project organization by keeping our project hierarchy as organized as possible: in our hierarchy, we grouped all the bunnies together, all the yellow collectibles together, all the walls together, and all the text together.

\subsection{Bunnies}
% TODO

\subsection{Terrain}
% TODO

\subsection{Walls}
  We created 4 identical walls to enclose the bunnies and our player, so that the player does not roll off the screen. These walls are duplicates of each other and their transforms were calculated and updated based on the size of our square-shaped ground.

\subsection{Collectibles}
  The 12 yellow collectibles are yellow cubes that are all based on the same prefab. All cubes are colored yellow to draw attention to themselves as collectibles that will gain the user points. Additionally, each collectible rotates in place around the surface of the play area.

\subsubsection{Rotating Collectibles}
  Each of the collectibles rotate in place. We were able to achieve this rotation effect by rotating the transform of each of our yellow collectibles in the \verb+Update()+ function so that the transform of each of our collectibles is updated in each frame. In our \verb+Update()+ function, we apply a rotation by a certain vector to the transforms of our collectibles, smoothed by a time delta (so that the rotations are frame rate independent and not extremely fast and jerky as they would be without the smoothing).

\subsection{Text}

We have 4 different texts in our game:

\begin{enumerate}
  \item Bunny Count Text - we have a floating bunnyiescounter in the upper left hand corner of our game. This number represents the number of bunnies that you have been able to roll over so far in the game. This text is automatically updated every time there is a trigger collision between the player (the sphere) and any of the bunnies (which are tagged as ``Bunny''). More specifically, when such a trigger collision occurs, we deactivate the bunny, increment our bunnies counter, and update our bunny count text.
  \item Score Text - we have a score displayed in the upper left hand corner of our game. This number represents the number of yellow collectibles that you have been able to collect so far in the game. This text is automatically updated every time there is a trigger collision between the player (the sphere) and any of the yellow collectibles (which are tagged as ``Collectibles''). More specifically, when such a trigger collision occurs, we deactivate the yellow collectible, increment our collectibles counter, and update our score text.
  \item Time Remaining Text - we have the time remaining displayed in the upper right hand corner of our game. This number represents the amount of time you have remaining to roll over all 9 bunnies as well as collect as many yellow collectibles you can. The time remaining starts at 60 seconds and is decremented every frame based on the time that has passed. This serves as a count down of how much time you have left before your game is scored.
  \item Win Text - once you complete the game, the win text will display over your player. The win text will either display ``You Win!'' if you won the game by rolling over all 9 bunnies, or ``You lose :('' if you were unable to roll over all 9 bunnies within the 60 seconds.
\end{enumerate}




\section{Camera Positioning}
  We wanted the user to be able to focus on his/her player's actions and achieved this by updating our camera's position so that it is always following the player's position. 

  We first attempted to update the camera position to be relative to the player's position by making the camera a child of the player, which unfortunately led to a very roll-heavy perspective of our scene because the player's sphere is rotating rapidly to move around and so the camera's point of view rotates with it. Thus, we took an alternative approach to capture the effect of our camera following our player: 

\subsection{Camera Following Player}
  We were able to capture the effect of our camera following our player by keeping our camera and player as two separate game objects with no hierarchical relationship between them.
  We realized that what we wanted to achieve was to make the camera's position, relative to the player's position, remain constant. 

  Thus, we introduced the idea of having an offset value.
  We first placed the camera in a position that is able to capture our player and its surrounding space as desired. 
  Then, in our camera's \verb+Start()+ function, we compute an offset that is the initial difference between the camera's position and the player's position. 
  Our goal is to have the camera and player have this same offset at every frame throughout the duration of the game, so we update the camera's transform at every frame in the function \verb+LateUpdate()+ so that it is located at the player's position plus the offset. 
  Updating the camera's transform in \verb+LateUpdate()+ rather than \verb+Update()+ allows us to ensure that we will update our camera's position only after all items have been processed in \verb+Update+, more specifically ensuring that the position of the camera is updated only after the player's position has been updated in that particular frame.
  This process allows the camera to maintain the same relative position to our player throughout the game, achieving the effect of having our camera follow our player, allowing the user to focus on his/her player's behavior.
  

\section{Design}
  We focused on our project's overall design so that our game runs efficiently and our codebase is maintainable.

\subsection{Collision Detection}
  We use trigger collision detection to update our bunnies counter and collectibles counter upon player collision with a bunny and yellow collectible respectively.
  In particular, we had originally set up our bunnies and yellow collectibles without rigid body components, so they were considered to be static. This meant that Unity would recalculate our static collider cache every frame. 

  In order to increase the efficiency of our game, we added rigid body components to all of our bunnies and yellow collectibles to update them to be dynamic colliders, eliminating the need to recalculate the static collider cache every frame. Additionally, we updated them to be kinematic rigid bodies so that they will not react to physics forces and instead can be animated and moved by its transform (otherwise, gravity would pull them down and through the ground since they are triggers). 
  In this way, we have efficient collision detection and are able to update our bunnies counter and collectibles counter upon the appropriate types of collisions. 

  To elaborate on our collision detection process, we also use the tag system to detect which objects our player is colliding with at each collision. We do this by introducing different tags for our bunny and collectibles prefabs. We then use the built-in function \verb+CompareTag()+ to efficiently compare the tag of any game object to the string value of our tag of choice. 

\subsection{Prefabs}
  We have used prefabs to make our codebase more well-structured and maintainable.
  In particular, prefabs allow us to create GameObjects with specific components, property values, and child GameObjects as a reusable Asset. This allows us to avoid duplication of code and instead create instances of the same GameObject when needed in the game. 

  In particular, we took advantage of prefabs in our implementation of our bunnies and yellow collectibles. We have a bunny prefab and a collectible prefab, which we were able to utilize to create instances of our 9 bunnies and 12 yellow collectibles. This allows us to have more easily maintainable code as we can now make changes to all of our bunnies or collectibles at once, rather than having to update each bunny or collectible individually.


\subsection{Assets}
  We have spruced up our project and have made it look more similar to reality by taking advantage of different Unity assets.
  % TODO


\section{Challenges}
\subsection{Learning Unity}
We were both new to Unity and have never coded in C\# before. As such, there was a steep learning curve for us, as we had to familiarize ourselves with the new programming language, framework, and terminology. We did so by completing many different online tutorials: \cite{tutorial-rab}, \cite{tutorial1}, \cite{tutorial-wam}.

Luckily, we had already learned a lot in CS 175 this semester and were able to identify similar ideas in Unity as those that we learned and implemented in the course. We realized that Unity provides many great wrappers

\subsection{Learning } 
% TODO
test

\begin{thebibliography}{999}

  \bibitem{tutorial-rab}
    Roll-A-Ball Tutorial, \\
    \url{https://unity3d.com/learn/tutorials/s/roll-ball-tutorial}

  \bibitem{tutorial1}
    Unity Interactive Tutorials, \\
    \url{https://unity3d.com/learn/tutorials/s/interactive-tutorials}

  \bibitem{documentation}
    Unity Scripting Reference, \\
    \url{https://docs.unity3d.com/ScriptReference/}

  \bibitem{tutorial-wam} 
    Whack-A-Mole Tutorial, \\
    \url{https://www.youtube.com/watch?v=m4M7VAn-bYk&t=736s}

  \end{thebibliography}


\end{document}
